// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package io.deephaven.proto.backplane.grpc.`object`


object ObjectServiceGrpc {
  @scala.deprecated(message="Marked as deprecated in proto file", "") val METHOD_FETCH_OBJECT: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest, io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.ObjectService", "FetchObject"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor.getServices().get(0).getMethods().get(0)))
      .build()
  
  val METHOD_MESSAGE_STREAM: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.`object`.StreamRequest, io.deephaven.proto.backplane.grpc.`object`.StreamResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.BIDI_STREAMING)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.ObjectService", "MessageStream"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.StreamRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.StreamResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor.getServices().get(0).getMethods().get(1)))
      .build()
  
  val METHOD_OPEN_MESSAGE_STREAM: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.`object`.StreamRequest, io.deephaven.proto.backplane.grpc.`object`.StreamResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.ObjectService", "OpenMessageStream"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.StreamRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.StreamResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor.getServices().get(0).getMethods().get(2)))
      .build()
  
  val METHOD_NEXT_MESSAGE_STREAM: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.`object`.StreamRequest, io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.ObjectService", "NextMessageStream"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.StreamRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor.getServices().get(0).getMethods().get(3)))
      .build()
  
  val SERVICE: _root_.io.grpc.ServiceDescriptor =
    _root_.io.grpc.ServiceDescriptor.newBuilder("io.deephaven.proto.backplane.grpc.ObjectService")
      .setSchemaDescriptor(new _root_.scalapb.grpc.ConcreteProtoFileDescriptorSupplier(io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor))
      .addMethod(METHOD_FETCH_OBJECT)
      .addMethod(METHOD_MESSAGE_STREAM)
      .addMethod(METHOD_OPEN_MESSAGE_STREAM)
      .addMethod(METHOD_NEXT_MESSAGE_STREAM)
      .build()
  
  trait ObjectService extends _root_.scalapb.grpc.AbstractService {
    override def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[ObjectService] = ObjectService
    /**
      * Fetches a server-side object as a binary payload and assorted other tickets pointing at
      * other server-side objects that may need to be read to properly use this payload. The binary
      * format is implementation specific, but the implementation should be specified by the "type"
      * identifier in the typed ticket.
      *
      * Deprecated in favor of MessageStream, which is able to handle the same content.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") def fetchObject(request: io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse]
    /**
      * Provides a generic stream feature for Deephaven instances to use to add arbitrary functionality.
      * Presently these take the form of "object type plugins", where server-side code can specify how
      * an object could be serialized and/or communicate with a client. This gRPC stream is somewhat lower level
      * than the plugin API, giving the server and client APIs features to correctly establish and
      * control the stream. At this time, this is limited to a "ConnectRequest" to start the call.
      *
      * The first message sent to the server is expected to have a ConnectRequest, indicating which
      * export ticket to connect to. It is an error for the client to attempt to connect to an object
      * that has no plugin for its object type installed.
      *
      * The first request sent by the client should be a ConnectRequest. No other client message should
      * be sent until the server responds. The server will respond with Data as soon as it is able (i.e.
      * once the object in question has been resolved and the plugin has responded), indicating that the
      * request was successful. After that point, the client may send Data requests.
      *
      * All replies from the server to the client contain Data instances. When sent from the server to
      * the client, Data contains a bytes payload created by the server implementation of the plugin,
      * and server-created export tickets containing any object references specified to be sent by the
      * server-side plugin. As server-created exports, they are already resolved, and can be fetched or
      * otherwise referenced right away. The client API is expected to wrap those tickets in appropriate
      * objects, and the client is expected to release those tickets as appropriate, according to the
      * plugin's use case. Note that it is possible for the "type" field to be null, indicating that
      * there is no corresponding ObjectType plugin for these exported objects. This limits the client
      * to specifying those tickets in a subsequent request, or releasing the ticket to let the object
      * be garbage collected on the server.
      *
      * All Data instances sent from the client likewise contain a bytes payload, and may contain
      * references to objects that already exist or may soon exist on the server, not just tickets sent
      * by this same plugin. Note however that if those tickets are not yet resolved, neither the current
      * Data nor subsequent requests can be processed by the plugin, as the required references can't be
      * resolved.
      *
      * Presently there is no explicit "close" message to send, but plugin implementations can devise
      * their own "half-close" protocol if they so choose. For now, if one end closes the connection,
      * the other is expected to follow suit by closing their end too. At present, if there is an error
      * with the stream, it is conveyed to the client in the usual gRPC fashion, but the server plugin
      * will only be informed that the stream closed.
      */
    def messageStream(responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]): _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamRequest]
    /**
      * Half of the browser-based (browser's can't do bidirectional streams without websockets)
      * implementation for MessageStream.
      */
    def openMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest, responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]): _root_.scala.Unit
    /**
      * Other half of the browser-based implementation for MessageStream.
      */
    def nextMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse]
  }
  
  object ObjectService extends _root_.scalapb.grpc.ServiceCompanion[ObjectService] {
    implicit def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[ObjectService] = this
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.ServiceDescriptor = io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor.getServices().get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.ServiceDescriptor = io.deephaven.proto.backplane.grpc.`object`.ObjectProto.scalaDescriptor.services(0)
    def bindService(serviceImpl: ObjectService, executionContext: scala.concurrent.ExecutionContext): _root_.io.grpc.ServerServiceDefinition =
      _root_.io.grpc.ServerServiceDefinition.builder(SERVICE)
      .addMethod(
        METHOD_FETCH_OBJECT,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse]) => {
          serviceImpl.fetchObject(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_MESSAGE_STREAM,
        _root_.io.grpc.stub.ServerCalls.asyncBidiStreamingCall((observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]) => {
          serviceImpl.messageStream(observer)
        }))
      .addMethod(
        METHOD_OPEN_MESSAGE_STREAM,
        _root_.io.grpc.stub.ServerCalls.asyncServerStreamingCall((request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]) => {
          serviceImpl.openMessageStream(request, observer)
        }))
      .addMethod(
        METHOD_NEXT_MESSAGE_STREAM,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse]) => {
          serviceImpl.nextMessageStream(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .build()
  }
  
  trait ObjectServiceBlockingClient {
    def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[ObjectService] = ObjectService
    /**
      * Fetches a server-side object as a binary payload and assorted other tickets pointing at
      * other server-side objects that may need to be read to properly use this payload. The binary
      * format is implementation specific, but the implementation should be specified by the "type"
      * identifier in the typed ticket.
      *
      * Deprecated in favor of MessageStream, which is able to handle the same content.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") def fetchObject(request: io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest): io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse
    /**
      * Half of the browser-based (browser's can't do bidirectional streams without websockets)
      * implementation for MessageStream.
      */
    def openMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest): scala.collection.Iterator[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]
    /**
      * Other half of the browser-based implementation for MessageStream.
      */
    def nextMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest): io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse
  }
  
  class ObjectServiceBlockingStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions = _root_.io.grpc.CallOptions.DEFAULT) extends _root_.io.grpc.stub.AbstractStub[ObjectServiceBlockingStub](channel, options) with ObjectServiceBlockingClient {
    /**
      * Fetches a server-side object as a binary payload and assorted other tickets pointing at
      * other server-side objects that may need to be read to properly use this payload. The binary
      * format is implementation specific, but the implementation should be specified by the "type"
      * identifier in the typed ticket.
      *
      * Deprecated in favor of MessageStream, which is able to handle the same content.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") override def fetchObject(request: io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest): io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_FETCH_OBJECT, options, request)
    }
    
    /**
      * Half of the browser-based (browser's can't do bidirectional streams without websockets)
      * implementation for MessageStream.
      */
    override def openMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest): scala.collection.Iterator[io.deephaven.proto.backplane.grpc.`object`.StreamResponse] = {
      _root_.scalapb.grpc.ClientCalls.blockingServerStreamingCall(channel, METHOD_OPEN_MESSAGE_STREAM, options, request)
    }
    
    /**
      * Other half of the browser-based implementation for MessageStream.
      */
    override def nextMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest): io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_NEXT_MESSAGE_STREAM, options, request)
    }
    
    override def build(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): ObjectServiceBlockingStub = new ObjectServiceBlockingStub(channel, options)
  }
  
  class ObjectServiceStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions = _root_.io.grpc.CallOptions.DEFAULT) extends _root_.io.grpc.stub.AbstractStub[ObjectServiceStub](channel, options) with ObjectService {
    /**
      * Fetches a server-side object as a binary payload and assorted other tickets pointing at
      * other server-side objects that may need to be read to properly use this payload. The binary
      * format is implementation specific, but the implementation should be specified by the "type"
      * identifier in the typed ticket.
      *
      * Deprecated in favor of MessageStream, which is able to handle the same content.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") override def fetchObject(request: io.deephaven.proto.backplane.grpc.`object`.FetchObjectRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.`object`.FetchObjectResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_FETCH_OBJECT, options, request)
    }
    
    /**
      * Provides a generic stream feature for Deephaven instances to use to add arbitrary functionality.
      * Presently these take the form of "object type plugins", where server-side code can specify how
      * an object could be serialized and/or communicate with a client. This gRPC stream is somewhat lower level
      * than the plugin API, giving the server and client APIs features to correctly establish and
      * control the stream. At this time, this is limited to a "ConnectRequest" to start the call.
      *
      * The first message sent to the server is expected to have a ConnectRequest, indicating which
      * export ticket to connect to. It is an error for the client to attempt to connect to an object
      * that has no plugin for its object type installed.
      *
      * The first request sent by the client should be a ConnectRequest. No other client message should
      * be sent until the server responds. The server will respond with Data as soon as it is able (i.e.
      * once the object in question has been resolved and the plugin has responded), indicating that the
      * request was successful. After that point, the client may send Data requests.
      *
      * All replies from the server to the client contain Data instances. When sent from the server to
      * the client, Data contains a bytes payload created by the server implementation of the plugin,
      * and server-created export tickets containing any object references specified to be sent by the
      * server-side plugin. As server-created exports, they are already resolved, and can be fetched or
      * otherwise referenced right away. The client API is expected to wrap those tickets in appropriate
      * objects, and the client is expected to release those tickets as appropriate, according to the
      * plugin's use case. Note that it is possible for the "type" field to be null, indicating that
      * there is no corresponding ObjectType plugin for these exported objects. This limits the client
      * to specifying those tickets in a subsequent request, or releasing the ticket to let the object
      * be garbage collected on the server.
      *
      * All Data instances sent from the client likewise contain a bytes payload, and may contain
      * references to objects that already exist or may soon exist on the server, not just tickets sent
      * by this same plugin. Note however that if those tickets are not yet resolved, neither the current
      * Data nor subsequent requests can be processed by the plugin, as the required references can't be
      * resolved.
      *
      * Presently there is no explicit "close" message to send, but plugin implementations can devise
      * their own "half-close" protocol if they so choose. For now, if one end closes the connection,
      * the other is expected to follow suit by closing their end too. At present, if there is an error
      * with the stream, it is conveyed to the client in the usual gRPC fashion, but the server plugin
      * will only be informed that the stream closed.
      */
    override def messageStream(responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]): _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamRequest] = {
      _root_.scalapb.grpc.ClientCalls.asyncBidiStreamingCall(channel, METHOD_MESSAGE_STREAM, options, responseObserver)
    }
    
    /**
      * Half of the browser-based (browser's can't do bidirectional streams without websockets)
      * implementation for MessageStream.
      */
    override def openMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest, responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.`object`.StreamResponse]): _root_.scala.Unit = {
      _root_.scalapb.grpc.ClientCalls.asyncServerStreamingCall(channel, METHOD_OPEN_MESSAGE_STREAM, options, request, responseObserver)
    }
    
    /**
      * Other half of the browser-based implementation for MessageStream.
      */
    override def nextMessageStream(request: io.deephaven.proto.backplane.grpc.`object`.StreamRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.`object`.BrowserNextResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_NEXT_MESSAGE_STREAM, options, request)
    }
    
    override def build(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): ObjectServiceStub = new ObjectServiceStub(channel, options)
  }
  
  object ObjectServiceStub extends _root_.io.grpc.stub.AbstractStub.StubFactory[ObjectServiceStub] {
    override def newStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): ObjectServiceStub = new ObjectServiceStub(channel, options)
    
    implicit val stubFactory: _root_.io.grpc.stub.AbstractStub.StubFactory[ObjectServiceStub] = this
  }
  
  def bindService(serviceImpl: ObjectService, executionContext: scala.concurrent.ExecutionContext): _root_.io.grpc.ServerServiceDefinition = ObjectService.bindService(serviceImpl, executionContext)
  
  def blockingStub(channel: _root_.io.grpc.Channel): ObjectServiceBlockingStub = new ObjectServiceBlockingStub(channel)
  
  def stub(channel: _root_.io.grpc.Channel): ObjectServiceStub = new ObjectServiceStub(channel)
  
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.ServiceDescriptor = io.deephaven.proto.backplane.grpc.`object`.ObjectProto.javaDescriptor.getServices().get(0)
  
}