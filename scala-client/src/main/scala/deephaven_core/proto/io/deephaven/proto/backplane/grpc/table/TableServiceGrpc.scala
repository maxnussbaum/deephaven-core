// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package io.deephaven.proto.backplane.grpc.table


object TableServiceGrpc {
  val METHOD_GET_EXPORTED_TABLE_CREATION_RESPONSE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.ticket.Ticket, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "GetExportedTableCreationResponse"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.ticket.Ticket])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(0)))
      .build()
  
  val METHOD_FETCH_TABLE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.FetchTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "FetchTable"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.FetchTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(1)))
      .build()
  
  val METHOD_APPLY_PREVIEW_COLUMNS: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "ApplyPreviewColumns"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(2)))
      .build()
  
  val METHOD_EMPTY_TABLE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.EmptyTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "EmptyTable"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.EmptyTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(3)))
      .build()
  
  val METHOD_TIME_TABLE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.TimeTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "TimeTable"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.TimeTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(4)))
      .build()
  
  val METHOD_DROP_COLUMNS: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.DropColumnsRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "DropColumns"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.DropColumnsRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(5)))
      .build()
  
  val METHOD_UPDATE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Update"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(6)))
      .build()
  
  val METHOD_LAZY_UPDATE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "LazyUpdate"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(7)))
      .build()
  
  val METHOD_VIEW: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "View"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(8)))
      .build()
  
  val METHOD_UPDATE_VIEW: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "UpdateView"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(9)))
      .build()
  
  val METHOD_SELECT: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Select"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(10)))
      .build()
  
  val METHOD_UPDATE_BY: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.UpdateByRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "UpdateBy"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.UpdateByRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(11)))
      .build()
  
  val METHOD_SELECT_DISTINCT: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "SelectDistinct"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(12)))
      .build()
  
  val METHOD_FILTER: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.FilterTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Filter"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.FilterTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(13)))
      .build()
  
  val METHOD_UNSTRUCTURED_FILTER: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "UnstructuredFilter"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(14)))
      .build()
  
  val METHOD_SORT: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SortTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Sort"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SortTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(15)))
      .build()
  
  val METHOD_HEAD: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Head"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(16)))
      .build()
  
  val METHOD_TAIL: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Tail"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(17)))
      .build()
  
  val METHOD_HEAD_BY: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "HeadBy"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(18)))
      .build()
  
  val METHOD_TAIL_BY: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "TailBy"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(19)))
      .build()
  
  val METHOD_UNGROUP: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.UngroupRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Ungroup"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.UngroupRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(20)))
      .build()
  
  val METHOD_MERGE_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.MergeTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "MergeTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.MergeTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(21)))
      .build()
  
  val METHOD_CROSS_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "CrossJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(22)))
      .build()
  
  val METHOD_NATURAL_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "NaturalJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(23)))
      .build()
  
  val METHOD_EXACT_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "ExactJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(24)))
      .build()
  
  val METHOD_LEFT_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "LeftJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(25)))
      .build()
  
  @scala.deprecated(message="Marked as deprecated in proto file", "") val METHOD_AS_OF_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "AsOfJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(26)))
      .build()
  
  val METHOD_AJ_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "AjTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(27)))
      .build()
  
  val METHOD_RAJ_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "RajTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(28)))
      .build()
  
  val METHOD_MULTI_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "MultiJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(29)))
      .build()
  
  val METHOD_RANGE_JOIN_TABLES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "RangeJoinTables"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(30)))
      .build()
  
  @scala.deprecated(message="Marked as deprecated in proto file", "") val METHOD_COMBO_AGGREGATE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "ComboAggregate"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(31)))
      .build()
  
  val METHOD_AGGREGATE_ALL: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.AggregateAllRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "AggregateAll"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.AggregateAllRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(32)))
      .build()
  
  val METHOD_AGGREGATE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.AggregateRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Aggregate"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.AggregateRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(33)))
      .build()
  
  val METHOD_SNAPSHOT: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Snapshot"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(34)))
      .build()
  
  val METHOD_SNAPSHOT_WHEN: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "SnapshotWhen"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(35)))
      .build()
  
  val METHOD_FLATTEN: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.FlattenRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Flatten"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.FlattenRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(36)))
      .build()
  
  val METHOD_RUN_CHART_DOWNSAMPLE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "RunChartDownsample"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(37)))
      .build()
  
  val METHOD_CREATE_INPUT_TABLE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "CreateInputTable"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(38)))
      .build()
  
  val METHOD_WHERE_IN: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.WhereInRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "WhereIn"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.WhereInRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(39)))
      .build()
  
  val METHOD_BATCH: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.BatchTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Batch"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.BatchTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(40)))
      .build()
  
  val METHOD_EXPORTED_TABLE_UPDATES: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "ExportedTableUpdates"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(41)))
      .build()
  
  val METHOD_SEEK_ROW: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SeekRowRequest, io.deephaven.proto.backplane.grpc.table.SeekRowResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "SeekRow"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SeekRowRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SeekRowResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(42)))
      .build()
  
  val METHOD_META_TABLE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.MetaTableRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "MetaTable"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.MetaTableRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(43)))
      .build()
  
  val METHOD_COMPUTE_COLUMN_STATISTICS: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "ComputeColumnStatistics"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(44)))
      .build()
  
  val METHOD_SLICE: _root_.io.grpc.MethodDescriptor[io.deephaven.proto.backplane.grpc.table.SliceRequest, io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("io.deephaven.proto.backplane.grpc.TableService", "Slice"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.SliceRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0).getMethods().get(45)))
      .build()
  
  val SERVICE: _root_.io.grpc.ServiceDescriptor =
    _root_.io.grpc.ServiceDescriptor.newBuilder("io.deephaven.proto.backplane.grpc.TableService")
      .setSchemaDescriptor(new _root_.scalapb.grpc.ConcreteProtoFileDescriptorSupplier(io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor))
      .addMethod(METHOD_GET_EXPORTED_TABLE_CREATION_RESPONSE)
      .addMethod(METHOD_FETCH_TABLE)
      .addMethod(METHOD_APPLY_PREVIEW_COLUMNS)
      .addMethod(METHOD_EMPTY_TABLE)
      .addMethod(METHOD_TIME_TABLE)
      .addMethod(METHOD_DROP_COLUMNS)
      .addMethod(METHOD_UPDATE)
      .addMethod(METHOD_LAZY_UPDATE)
      .addMethod(METHOD_VIEW)
      .addMethod(METHOD_UPDATE_VIEW)
      .addMethod(METHOD_SELECT)
      .addMethod(METHOD_UPDATE_BY)
      .addMethod(METHOD_SELECT_DISTINCT)
      .addMethod(METHOD_FILTER)
      .addMethod(METHOD_UNSTRUCTURED_FILTER)
      .addMethod(METHOD_SORT)
      .addMethod(METHOD_HEAD)
      .addMethod(METHOD_TAIL)
      .addMethod(METHOD_HEAD_BY)
      .addMethod(METHOD_TAIL_BY)
      .addMethod(METHOD_UNGROUP)
      .addMethod(METHOD_MERGE_TABLES)
      .addMethod(METHOD_CROSS_JOIN_TABLES)
      .addMethod(METHOD_NATURAL_JOIN_TABLES)
      .addMethod(METHOD_EXACT_JOIN_TABLES)
      .addMethod(METHOD_LEFT_JOIN_TABLES)
      .addMethod(METHOD_AS_OF_JOIN_TABLES)
      .addMethod(METHOD_AJ_TABLES)
      .addMethod(METHOD_RAJ_TABLES)
      .addMethod(METHOD_MULTI_JOIN_TABLES)
      .addMethod(METHOD_RANGE_JOIN_TABLES)
      .addMethod(METHOD_COMBO_AGGREGATE)
      .addMethod(METHOD_AGGREGATE_ALL)
      .addMethod(METHOD_AGGREGATE)
      .addMethod(METHOD_SNAPSHOT)
      .addMethod(METHOD_SNAPSHOT_WHEN)
      .addMethod(METHOD_FLATTEN)
      .addMethod(METHOD_RUN_CHART_DOWNSAMPLE)
      .addMethod(METHOD_CREATE_INPUT_TABLE)
      .addMethod(METHOD_WHERE_IN)
      .addMethod(METHOD_BATCH)
      .addMethod(METHOD_EXPORTED_TABLE_UPDATES)
      .addMethod(METHOD_SEEK_ROW)
      .addMethod(METHOD_META_TABLE)
      .addMethod(METHOD_COMPUTE_COLUMN_STATISTICS)
      .addMethod(METHOD_SLICE)
      .build()
  
  trait TableService extends _root_.scalapb.grpc.AbstractService {
    override def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[TableService] = TableService
    /**
      * Request an ETCR for this ticket. Ticket must reference a Table.
      */
    def getExportedTableCreationResponse(request: io.deephaven.proto.backplane.grpc.ticket.Ticket): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Fetches a Table from an existing source ticket and exports it to the local session result ticket.
      */
    def fetchTable(request: io.deephaven.proto.backplane.grpc.table.FetchTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Create a table that has preview columns applied to an existing source table.
      */
    def applyPreviewColumns(request: io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Create an empty table with the given column names and types.
      */
    def emptyTable(request: io.deephaven.proto.backplane.grpc.table.EmptyTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Create a time table with the given start time and period.
      */
    def timeTable(request: io.deephaven.proto.backplane.grpc.table.TimeTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Drop columns from the parent table.
      */
    def dropColumns(request: io.deephaven.proto.backplane.grpc.table.DropColumnsRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Add columns to the given table using the given column specifications and the update table operation.
      */
    def update(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Add columns to the given table using the given column specifications and the lazyUpdate table operation.
      */
    def lazyUpdate(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Add columns to the given table using the given column specifications and the view table operation.
      */
    def view(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Add columns to the given table using the given column specifications and the updateView table operation.
      */
    def updateView(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Select the given columns from the given table.
      */
    def select(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of an updateBy table operation.
      */
    def updateBy(request: io.deephaven.proto.backplane.grpc.table.UpdateByRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns a new table definition with the unique tuples of the specified columns
      */
    def selectDistinct(request: io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Filter parent table with structured filters.
      */
    def filter(request: io.deephaven.proto.backplane.grpc.table.FilterTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Filter parent table with unstructured filters.
      */
    def unstructuredFilter(request: io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Sort parent table via the provide sort descriptors.
      */
    def sort(request: io.deephaven.proto.backplane.grpc.table.SortTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Extract rows from the head of the parent table.
      */
    def head(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Extract rows from the tail of the parent table.
      */
    def tail(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Run the headBy table operation for the given group by columns on the given table.
      */
    def headBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Run the tailBy operation for the given group by columns on the given table.
      */
    def tailBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
      */
    def ungroup(request: io.deephaven.proto.backplane.grpc.table.UngroupRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Create a merged table from the given input tables. If a key column is provided (not null), a sorted
      * merged will be performed using that column.
      */
    def mergeTables(request: io.deephaven.proto.backplane.grpc.table.MergeTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of a cross join operation. Also known as the cartesian product.
      */
    def crossJoinTables(request: io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of a natural join operation.
      */
    def naturalJoinTables(request: io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of an exact join operation.
      */
    def exactJoinTables(request: io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of a left join operation.
      */
    def leftJoinTables(request: io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of an as of join operation.
      *
      * Deprecated: Please use AjTables or RajTables.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") def asOfJoinTables(request: io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of an aj operation.
      */
    def ajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of an raj operation.
      */
    def rajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of a multi-join operation.
      */
    def multiJoinTables(request: io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of a range join operation.
      */
    def rangeJoinTables(request: io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns the result of an aggregate table operation.
      *
      * Deprecated: Please use AggregateAll or Aggregate instead
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") def comboAggregate(request: io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Aggregates all non-grouping columns against a single aggregation specification.
      */
    def aggregateAll(request: io.deephaven.proto.backplane.grpc.table.AggregateAllRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Produce an aggregated result by grouping the source_id table according to the group_by_columns and applying
      * aggregations to each resulting group of rows. The result table will have one row per group, ordered by
      * the encounter order within the source_id table, thereby ensuring that the row key for a given group never
      * changes.
      */
    def aggregate(request: io.deephaven.proto.backplane.grpc.table.AggregateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Takes a single snapshot of the source_id table.
      */
    def snapshot(request: io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Snapshot base_id, triggered by trigger_id, and export the resulting new table.
      * The trigger_id table's change events cause a new snapshot to be taken. The result table includes a
      * "snapshot key" which is a subset (possibly all) of the base_id table's columns. The
      * remaining columns in the result table come from base_id table, the table being snapshotted.
      */
    def snapshotWhen(request: io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Returns a new table with a flattened row set.
      */
    def flatten(request: io.deephaven.proto.backplane.grpc.table.FlattenRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /** *
      * Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
      * X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
      * column to support zooming in.
      */
    def runChartDownsample(request: io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /** *
      * Creates a new Table based on the provided configuration. This can be used as a regular table from the other methods
      * in this interface, or can be interacted with via the InputTableService to modify its contents.
      */
    def createInputTable(request: io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /** *
      * Filters the left table based on the set of values in the right table.
      *
      * Note that when the right table ticks, all of the rows in the left table are going to be re-evaluated,
      * thus the intention is that the right table is fairly slow moving compared with the left table.
      */
    def whereIn(request: io.deephaven.proto.backplane.grpc.table.WhereInRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
      * requiring them to be exported and managed by the client. The server will automatically release any tables when they
      * are no longer depended upon.
      */
    def batch(request: io.deephaven.proto.backplane.grpc.table.BatchTableRequest, responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]): _root_.scala.Unit
    /**
      * Establish a stream of table updates for cheap notifications of table size updates.
      *
      * New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
      * exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
      * initial update had been sent.
      */
    def exportedTableUpdates(request: io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest, responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage]): _root_.scala.Unit
    /**
      * Seek a row number within a table.
      */
    def seekRow(request: io.deephaven.proto.backplane.grpc.table.SeekRowRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.SeekRowResponse]
    /**
      * Returns the meta table of a table.
      */
    def metaTable(request: io.deephaven.proto.backplane.grpc.table.MetaTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /** *
      * Returns a new table representing statistics about a single column of the provided table. This
      * result table will be static - use Aggregation() instead for updating results. Presently, the
      * primary use case for this is the Deephaven Web UI.
      */
    def computeColumnStatistics(request: io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /** *
      * Returns a new table representing a sliced subset of the original table. The start position is inclusive
      * and the end position is exclusive. If a negative value is given, then the position is counted from the end of
      * the table.
      */
    def slice(request: io.deephaven.proto.backplane.grpc.table.SliceRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
  }
  
  object TableService extends _root_.scalapb.grpc.ServiceCompanion[TableService] {
    implicit def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[TableService] = this
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.ServiceDescriptor = io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.ServiceDescriptor = io.deephaven.proto.backplane.grpc.table.TableProto.scalaDescriptor.services(0)
    def bindService(serviceImpl: TableService, executionContext: scala.concurrent.ExecutionContext): _root_.io.grpc.ServerServiceDefinition =
      _root_.io.grpc.ServerServiceDefinition.builder(SERVICE)
      .addMethod(
        METHOD_GET_EXPORTED_TABLE_CREATION_RESPONSE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.ticket.Ticket, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.getExportedTableCreationResponse(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_FETCH_TABLE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.FetchTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.fetchTable(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_APPLY_PREVIEW_COLUMNS,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.applyPreviewColumns(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_EMPTY_TABLE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.EmptyTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.emptyTable(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_TIME_TABLE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.TimeTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.timeTable(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_DROP_COLUMNS,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.DropColumnsRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.dropColumns(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_UPDATE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.update(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_LAZY_UPDATE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.lazyUpdate(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_VIEW,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.view(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_UPDATE_VIEW,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.updateView(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_SELECT,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.select(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_UPDATE_BY,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.UpdateByRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.updateBy(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_SELECT_DISTINCT,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.selectDistinct(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_FILTER,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.FilterTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.filter(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_UNSTRUCTURED_FILTER,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.unstructuredFilter(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_SORT,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SortTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.sort(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_HEAD,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.head(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_TAIL,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.tail(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_HEAD_BY,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.headBy(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_TAIL_BY,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.tailBy(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_UNGROUP,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.UngroupRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.ungroup(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_MERGE_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.MergeTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.mergeTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_CROSS_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.crossJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_NATURAL_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.naturalJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_EXACT_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.exactJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_LEFT_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.leftJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_AS_OF_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.asOfJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_AJ_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.ajTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_RAJ_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.rajTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_MULTI_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.multiJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_RANGE_JOIN_TABLES,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.rangeJoinTables(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_COMBO_AGGREGATE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.comboAggregate(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_AGGREGATE_ALL,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.AggregateAllRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.aggregateAll(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_AGGREGATE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.AggregateRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.aggregate(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_SNAPSHOT,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.snapshot(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_SNAPSHOT_WHEN,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.snapshotWhen(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_FLATTEN,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.FlattenRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.flatten(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_RUN_CHART_DOWNSAMPLE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.runChartDownsample(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_CREATE_INPUT_TABLE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.createInputTable(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_WHERE_IN,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.WhereInRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.whereIn(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_BATCH,
        _root_.io.grpc.stub.ServerCalls.asyncServerStreamingCall((request: io.deephaven.proto.backplane.grpc.table.BatchTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.batch(request, observer)
        }))
      .addMethod(
        METHOD_EXPORTED_TABLE_UPDATES,
        _root_.io.grpc.stub.ServerCalls.asyncServerStreamingCall((request: io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage]) => {
          serviceImpl.exportedTableUpdates(request, observer)
        }))
      .addMethod(
        METHOD_SEEK_ROW,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SeekRowRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.SeekRowResponse]) => {
          serviceImpl.seekRow(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_META_TABLE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.MetaTableRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.metaTable(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_COMPUTE_COLUMN_STATISTICS,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.computeColumnStatistics(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_SLICE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: io.deephaven.proto.backplane.grpc.table.SliceRequest, observer: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]) => {
          serviceImpl.slice(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .build()
  }
  
  trait TableServiceBlockingClient {
    def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[TableService] = TableService
    /**
      * Request an ETCR for this ticket. Ticket must reference a Table.
      */
    def getExportedTableCreationResponse(request: io.deephaven.proto.backplane.grpc.ticket.Ticket): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Fetches a Table from an existing source ticket and exports it to the local session result ticket.
      */
    def fetchTable(request: io.deephaven.proto.backplane.grpc.table.FetchTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Create a table that has preview columns applied to an existing source table.
      */
    def applyPreviewColumns(request: io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Create an empty table with the given column names and types.
      */
    def emptyTable(request: io.deephaven.proto.backplane.grpc.table.EmptyTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Create a time table with the given start time and period.
      */
    def timeTable(request: io.deephaven.proto.backplane.grpc.table.TimeTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Drop columns from the parent table.
      */
    def dropColumns(request: io.deephaven.proto.backplane.grpc.table.DropColumnsRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Add columns to the given table using the given column specifications and the update table operation.
      */
    def update(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Add columns to the given table using the given column specifications and the lazyUpdate table operation.
      */
    def lazyUpdate(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Add columns to the given table using the given column specifications and the view table operation.
      */
    def view(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Add columns to the given table using the given column specifications and the updateView table operation.
      */
    def updateView(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Select the given columns from the given table.
      */
    def select(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of an updateBy table operation.
      */
    def updateBy(request: io.deephaven.proto.backplane.grpc.table.UpdateByRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns a new table definition with the unique tuples of the specified columns
      */
    def selectDistinct(request: io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Filter parent table with structured filters.
      */
    def filter(request: io.deephaven.proto.backplane.grpc.table.FilterTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Filter parent table with unstructured filters.
      */
    def unstructuredFilter(request: io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Sort parent table via the provide sort descriptors.
      */
    def sort(request: io.deephaven.proto.backplane.grpc.table.SortTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Extract rows from the head of the parent table.
      */
    def head(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Extract rows from the tail of the parent table.
      */
    def tail(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Run the headBy table operation for the given group by columns on the given table.
      */
    def headBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Run the tailBy operation for the given group by columns on the given table.
      */
    def tailBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
      */
    def ungroup(request: io.deephaven.proto.backplane.grpc.table.UngroupRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Create a merged table from the given input tables. If a key column is provided (not null), a sorted
      * merged will be performed using that column.
      */
    def mergeTables(request: io.deephaven.proto.backplane.grpc.table.MergeTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of a cross join operation. Also known as the cartesian product.
      */
    def crossJoinTables(request: io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of a natural join operation.
      */
    def naturalJoinTables(request: io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of an exact join operation.
      */
    def exactJoinTables(request: io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of a left join operation.
      */
    def leftJoinTables(request: io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of an as of join operation.
      *
      * Deprecated: Please use AjTables or RajTables.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") def asOfJoinTables(request: io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of an aj operation.
      */
    def ajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of an raj operation.
      */
    def rajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of a multi-join operation.
      */
    def multiJoinTables(request: io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of a range join operation.
      */
    def rangeJoinTables(request: io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns the result of an aggregate table operation.
      *
      * Deprecated: Please use AggregateAll or Aggregate instead
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") def comboAggregate(request: io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Aggregates all non-grouping columns against a single aggregation specification.
      */
    def aggregateAll(request: io.deephaven.proto.backplane.grpc.table.AggregateAllRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Produce an aggregated result by grouping the source_id table according to the group_by_columns and applying
      * aggregations to each resulting group of rows. The result table will have one row per group, ordered by
      * the encounter order within the source_id table, thereby ensuring that the row key for a given group never
      * changes.
      */
    def aggregate(request: io.deephaven.proto.backplane.grpc.table.AggregateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Takes a single snapshot of the source_id table.
      */
    def snapshot(request: io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Snapshot base_id, triggered by trigger_id, and export the resulting new table.
      * The trigger_id table's change events cause a new snapshot to be taken. The result table includes a
      * "snapshot key" which is a subset (possibly all) of the base_id table's columns. The
      * remaining columns in the result table come from base_id table, the table being snapshotted.
      */
    def snapshotWhen(request: io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Returns a new table with a flattened row set.
      */
    def flatten(request: io.deephaven.proto.backplane.grpc.table.FlattenRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /** *
      * Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
      * X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
      * column to support zooming in.
      */
    def runChartDownsample(request: io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /** *
      * Creates a new Table based on the provided configuration. This can be used as a regular table from the other methods
      * in this interface, or can be interacted with via the InputTableService to modify its contents.
      */
    def createInputTable(request: io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /** *
      * Filters the left table based on the set of values in the right table.
      *
      * Note that when the right table ticks, all of the rows in the left table are going to be re-evaluated,
      * thus the intention is that the right table is fairly slow moving compared with the left table.
      */
    def whereIn(request: io.deephaven.proto.backplane.grpc.table.WhereInRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /**
      * Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
      * requiring them to be exported and managed by the client. The server will automatically release any tables when they
      * are no longer depended upon.
      */
    def batch(request: io.deephaven.proto.backplane.grpc.table.BatchTableRequest): scala.collection.Iterator[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]
    /**
      * Establish a stream of table updates for cheap notifications of table size updates.
      *
      * New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
      * exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
      * initial update had been sent.
      */
    def exportedTableUpdates(request: io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest): scala.collection.Iterator[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage]
    /**
      * Seek a row number within a table.
      */
    def seekRow(request: io.deephaven.proto.backplane.grpc.table.SeekRowRequest): io.deephaven.proto.backplane.grpc.table.SeekRowResponse
    /**
      * Returns the meta table of a table.
      */
    def metaTable(request: io.deephaven.proto.backplane.grpc.table.MetaTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /** *
      * Returns a new table representing statistics about a single column of the provided table. This
      * result table will be static - use Aggregation() instead for updating results. Presently, the
      * primary use case for this is the Deephaven Web UI.
      */
    def computeColumnStatistics(request: io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
    /** *
      * Returns a new table representing a sliced subset of the original table. The start position is inclusive
      * and the end position is exclusive. If a negative value is given, then the position is counted from the end of
      * the table.
      */
    def slice(request: io.deephaven.proto.backplane.grpc.table.SliceRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse
  }
  
  class TableServiceBlockingStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions = _root_.io.grpc.CallOptions.DEFAULT) extends _root_.io.grpc.stub.AbstractStub[TableServiceBlockingStub](channel, options) with TableServiceBlockingClient {
    /**
      * Request an ETCR for this ticket. Ticket must reference a Table.
      */
    override def getExportedTableCreationResponse(request: io.deephaven.proto.backplane.grpc.ticket.Ticket): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_GET_EXPORTED_TABLE_CREATION_RESPONSE, options, request)
    }
    
    /**
      * Fetches a Table from an existing source ticket and exports it to the local session result ticket.
      */
    override def fetchTable(request: io.deephaven.proto.backplane.grpc.table.FetchTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_FETCH_TABLE, options, request)
    }
    
    /**
      * Create a table that has preview columns applied to an existing source table.
      */
    override def applyPreviewColumns(request: io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_APPLY_PREVIEW_COLUMNS, options, request)
    }
    
    /**
      * Create an empty table with the given column names and types.
      */
    override def emptyTable(request: io.deephaven.proto.backplane.grpc.table.EmptyTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_EMPTY_TABLE, options, request)
    }
    
    /**
      * Create a time table with the given start time and period.
      */
    override def timeTable(request: io.deephaven.proto.backplane.grpc.table.TimeTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_TIME_TABLE, options, request)
    }
    
    /**
      * Drop columns from the parent table.
      */
    override def dropColumns(request: io.deephaven.proto.backplane.grpc.table.DropColumnsRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_DROP_COLUMNS, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the update table operation.
      */
    override def update(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_UPDATE, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the lazyUpdate table operation.
      */
    override def lazyUpdate(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_LAZY_UPDATE, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the view table operation.
      */
    override def view(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_VIEW, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the updateView table operation.
      */
    override def updateView(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_UPDATE_VIEW, options, request)
    }
    
    /**
      * Select the given columns from the given table.
      */
    override def select(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SELECT, options, request)
    }
    
    /**
      * Returns the result of an updateBy table operation.
      */
    override def updateBy(request: io.deephaven.proto.backplane.grpc.table.UpdateByRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_UPDATE_BY, options, request)
    }
    
    /**
      * Returns a new table definition with the unique tuples of the specified columns
      */
    override def selectDistinct(request: io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SELECT_DISTINCT, options, request)
    }
    
    /**
      * Filter parent table with structured filters.
      */
    override def filter(request: io.deephaven.proto.backplane.grpc.table.FilterTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_FILTER, options, request)
    }
    
    /**
      * Filter parent table with unstructured filters.
      */
    override def unstructuredFilter(request: io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_UNSTRUCTURED_FILTER, options, request)
    }
    
    /**
      * Sort parent table via the provide sort descriptors.
      */
    override def sort(request: io.deephaven.proto.backplane.grpc.table.SortTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SORT, options, request)
    }
    
    /**
      * Extract rows from the head of the parent table.
      */
    override def head(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_HEAD, options, request)
    }
    
    /**
      * Extract rows from the tail of the parent table.
      */
    override def tail(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_TAIL, options, request)
    }
    
    /**
      * Run the headBy table operation for the given group by columns on the given table.
      */
    override def headBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_HEAD_BY, options, request)
    }
    
    /**
      * Run the tailBy operation for the given group by columns on the given table.
      */
    override def tailBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_TAIL_BY, options, request)
    }
    
    /**
      * Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
      */
    override def ungroup(request: io.deephaven.proto.backplane.grpc.table.UngroupRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_UNGROUP, options, request)
    }
    
    /**
      * Create a merged table from the given input tables. If a key column is provided (not null), a sorted
      * merged will be performed using that column.
      */
    override def mergeTables(request: io.deephaven.proto.backplane.grpc.table.MergeTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_MERGE_TABLES, options, request)
    }
    
    /**
      * Returns the result of a cross join operation. Also known as the cartesian product.
      */
    override def crossJoinTables(request: io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_CROSS_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of a natural join operation.
      */
    override def naturalJoinTables(request: io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_NATURAL_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an exact join operation.
      */
    override def exactJoinTables(request: io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_EXACT_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of a left join operation.
      */
    override def leftJoinTables(request: io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_LEFT_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an as of join operation.
      *
      * Deprecated: Please use AjTables or RajTables.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") override def asOfJoinTables(request: io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_AS_OF_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an aj operation.
      */
    override def ajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_AJ_TABLES, options, request)
    }
    
    /**
      * Returns the result of an raj operation.
      */
    override def rajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_RAJ_TABLES, options, request)
    }
    
    /**
      * Returns the result of a multi-join operation.
      */
    override def multiJoinTables(request: io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_MULTI_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of a range join operation.
      */
    override def rangeJoinTables(request: io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_RANGE_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an aggregate table operation.
      *
      * Deprecated: Please use AggregateAll or Aggregate instead
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") override def comboAggregate(request: io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_COMBO_AGGREGATE, options, request)
    }
    
    /**
      * Aggregates all non-grouping columns against a single aggregation specification.
      */
    override def aggregateAll(request: io.deephaven.proto.backplane.grpc.table.AggregateAllRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_AGGREGATE_ALL, options, request)
    }
    
    /**
      * Produce an aggregated result by grouping the source_id table according to the group_by_columns and applying
      * aggregations to each resulting group of rows. The result table will have one row per group, ordered by
      * the encounter order within the source_id table, thereby ensuring that the row key for a given group never
      * changes.
      */
    override def aggregate(request: io.deephaven.proto.backplane.grpc.table.AggregateRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_AGGREGATE, options, request)
    }
    
    /**
      * Takes a single snapshot of the source_id table.
      */
    override def snapshot(request: io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SNAPSHOT, options, request)
    }
    
    /**
      * Snapshot base_id, triggered by trigger_id, and export the resulting new table.
      * The trigger_id table's change events cause a new snapshot to be taken. The result table includes a
      * "snapshot key" which is a subset (possibly all) of the base_id table's columns. The
      * remaining columns in the result table come from base_id table, the table being snapshotted.
      */
    override def snapshotWhen(request: io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SNAPSHOT_WHEN, options, request)
    }
    
    /**
      * Returns a new table with a flattened row set.
      */
    override def flatten(request: io.deephaven.proto.backplane.grpc.table.FlattenRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_FLATTEN, options, request)
    }
    
    /** *
      * Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
      * X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
      * column to support zooming in.
      */
    override def runChartDownsample(request: io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_RUN_CHART_DOWNSAMPLE, options, request)
    }
    
    /** *
      * Creates a new Table based on the provided configuration. This can be used as a regular table from the other methods
      * in this interface, or can be interacted with via the InputTableService to modify its contents.
      */
    override def createInputTable(request: io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_CREATE_INPUT_TABLE, options, request)
    }
    
    /** *
      * Filters the left table based on the set of values in the right table.
      *
      * Note that when the right table ticks, all of the rows in the left table are going to be re-evaluated,
      * thus the intention is that the right table is fairly slow moving compared with the left table.
      */
    override def whereIn(request: io.deephaven.proto.backplane.grpc.table.WhereInRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_WHERE_IN, options, request)
    }
    
    /**
      * Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
      * requiring them to be exported and managed by the client. The server will automatically release any tables when they
      * are no longer depended upon.
      */
    override def batch(request: io.deephaven.proto.backplane.grpc.table.BatchTableRequest): scala.collection.Iterator[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.blockingServerStreamingCall(channel, METHOD_BATCH, options, request)
    }
    
    /**
      * Establish a stream of table updates for cheap notifications of table size updates.
      *
      * New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
      * exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
      * initial update had been sent.
      */
    override def exportedTableUpdates(request: io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest): scala.collection.Iterator[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage] = {
      _root_.scalapb.grpc.ClientCalls.blockingServerStreamingCall(channel, METHOD_EXPORTED_TABLE_UPDATES, options, request)
    }
    
    /**
      * Seek a row number within a table.
      */
    override def seekRow(request: io.deephaven.proto.backplane.grpc.table.SeekRowRequest): io.deephaven.proto.backplane.grpc.table.SeekRowResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SEEK_ROW, options, request)
    }
    
    /**
      * Returns the meta table of a table.
      */
    override def metaTable(request: io.deephaven.proto.backplane.grpc.table.MetaTableRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_META_TABLE, options, request)
    }
    
    /** *
      * Returns a new table representing statistics about a single column of the provided table. This
      * result table will be static - use Aggregation() instead for updating results. Presently, the
      * primary use case for this is the Deephaven Web UI.
      */
    override def computeColumnStatistics(request: io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_COMPUTE_COLUMN_STATISTICS, options, request)
    }
    
    /** *
      * Returns a new table representing a sliced subset of the original table. The start position is inclusive
      * and the end position is exclusive. If a negative value is given, then the position is counted from the end of
      * the table.
      */
    override def slice(request: io.deephaven.proto.backplane.grpc.table.SliceRequest): io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_SLICE, options, request)
    }
    
    override def build(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): TableServiceBlockingStub = new TableServiceBlockingStub(channel, options)
  }
  
  class TableServiceStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions = _root_.io.grpc.CallOptions.DEFAULT) extends _root_.io.grpc.stub.AbstractStub[TableServiceStub](channel, options) with TableService {
    /**
      * Request an ETCR for this ticket. Ticket must reference a Table.
      */
    override def getExportedTableCreationResponse(request: io.deephaven.proto.backplane.grpc.ticket.Ticket): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_GET_EXPORTED_TABLE_CREATION_RESPONSE, options, request)
    }
    
    /**
      * Fetches a Table from an existing source ticket and exports it to the local session result ticket.
      */
    override def fetchTable(request: io.deephaven.proto.backplane.grpc.table.FetchTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_FETCH_TABLE, options, request)
    }
    
    /**
      * Create a table that has preview columns applied to an existing source table.
      */
    override def applyPreviewColumns(request: io.deephaven.proto.backplane.grpc.table.ApplyPreviewColumnsRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_APPLY_PREVIEW_COLUMNS, options, request)
    }
    
    /**
      * Create an empty table with the given column names and types.
      */
    override def emptyTable(request: io.deephaven.proto.backplane.grpc.table.EmptyTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_EMPTY_TABLE, options, request)
    }
    
    /**
      * Create a time table with the given start time and period.
      */
    override def timeTable(request: io.deephaven.proto.backplane.grpc.table.TimeTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_TIME_TABLE, options, request)
    }
    
    /**
      * Drop columns from the parent table.
      */
    override def dropColumns(request: io.deephaven.proto.backplane.grpc.table.DropColumnsRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_DROP_COLUMNS, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the update table operation.
      */
    override def update(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_UPDATE, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the lazyUpdate table operation.
      */
    override def lazyUpdate(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_LAZY_UPDATE, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the view table operation.
      */
    override def view(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_VIEW, options, request)
    }
    
    /**
      * Add columns to the given table using the given column specifications and the updateView table operation.
      */
    override def updateView(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_UPDATE_VIEW, options, request)
    }
    
    /**
      * Select the given columns from the given table.
      */
    override def select(request: io.deephaven.proto.backplane.grpc.table.SelectOrUpdateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SELECT, options, request)
    }
    
    /**
      * Returns the result of an updateBy table operation.
      */
    override def updateBy(request: io.deephaven.proto.backplane.grpc.table.UpdateByRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_UPDATE_BY, options, request)
    }
    
    /**
      * Returns a new table definition with the unique tuples of the specified columns
      */
    override def selectDistinct(request: io.deephaven.proto.backplane.grpc.table.SelectDistinctRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SELECT_DISTINCT, options, request)
    }
    
    /**
      * Filter parent table with structured filters.
      */
    override def filter(request: io.deephaven.proto.backplane.grpc.table.FilterTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_FILTER, options, request)
    }
    
    /**
      * Filter parent table with unstructured filters.
      */
    override def unstructuredFilter(request: io.deephaven.proto.backplane.grpc.table.UnstructuredFilterTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_UNSTRUCTURED_FILTER, options, request)
    }
    
    /**
      * Sort parent table via the provide sort descriptors.
      */
    override def sort(request: io.deephaven.proto.backplane.grpc.table.SortTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SORT, options, request)
    }
    
    /**
      * Extract rows from the head of the parent table.
      */
    override def head(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_HEAD, options, request)
    }
    
    /**
      * Extract rows from the tail of the parent table.
      */
    override def tail(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_TAIL, options, request)
    }
    
    /**
      * Run the headBy table operation for the given group by columns on the given table.
      */
    override def headBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_HEAD_BY, options, request)
    }
    
    /**
      * Run the tailBy operation for the given group by columns on the given table.
      */
    override def tailBy(request: io.deephaven.proto.backplane.grpc.table.HeadOrTailByRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_TAIL_BY, options, request)
    }
    
    /**
      * Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
      */
    override def ungroup(request: io.deephaven.proto.backplane.grpc.table.UngroupRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_UNGROUP, options, request)
    }
    
    /**
      * Create a merged table from the given input tables. If a key column is provided (not null), a sorted
      * merged will be performed using that column.
      */
    override def mergeTables(request: io.deephaven.proto.backplane.grpc.table.MergeTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_MERGE_TABLES, options, request)
    }
    
    /**
      * Returns the result of a cross join operation. Also known as the cartesian product.
      */
    override def crossJoinTables(request: io.deephaven.proto.backplane.grpc.table.CrossJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_CROSS_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of a natural join operation.
      */
    override def naturalJoinTables(request: io.deephaven.proto.backplane.grpc.table.NaturalJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_NATURAL_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an exact join operation.
      */
    override def exactJoinTables(request: io.deephaven.proto.backplane.grpc.table.ExactJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_EXACT_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of a left join operation.
      */
    override def leftJoinTables(request: io.deephaven.proto.backplane.grpc.table.LeftJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_LEFT_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an as of join operation.
      *
      * Deprecated: Please use AjTables or RajTables.
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") override def asOfJoinTables(request: io.deephaven.proto.backplane.grpc.table.AsOfJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_AS_OF_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an aj operation.
      */
    override def ajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_AJ_TABLES, options, request)
    }
    
    /**
      * Returns the result of an raj operation.
      */
    override def rajTables(request: io.deephaven.proto.backplane.grpc.table.AjRajTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_RAJ_TABLES, options, request)
    }
    
    /**
      * Returns the result of a multi-join operation.
      */
    override def multiJoinTables(request: io.deephaven.proto.backplane.grpc.table.MultiJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_MULTI_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of a range join operation.
      */
    override def rangeJoinTables(request: io.deephaven.proto.backplane.grpc.table.RangeJoinTablesRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_RANGE_JOIN_TABLES, options, request)
    }
    
    /**
      * Returns the result of an aggregate table operation.
      *
      * Deprecated: Please use AggregateAll or Aggregate instead
      */
    @scala.deprecated(message="Marked as deprecated in proto file", "") override def comboAggregate(request: io.deephaven.proto.backplane.grpc.table.ComboAggregateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_COMBO_AGGREGATE, options, request)
    }
    
    /**
      * Aggregates all non-grouping columns against a single aggregation specification.
      */
    override def aggregateAll(request: io.deephaven.proto.backplane.grpc.table.AggregateAllRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_AGGREGATE_ALL, options, request)
    }
    
    /**
      * Produce an aggregated result by grouping the source_id table according to the group_by_columns and applying
      * aggregations to each resulting group of rows. The result table will have one row per group, ordered by
      * the encounter order within the source_id table, thereby ensuring that the row key for a given group never
      * changes.
      */
    override def aggregate(request: io.deephaven.proto.backplane.grpc.table.AggregateRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_AGGREGATE, options, request)
    }
    
    /**
      * Takes a single snapshot of the source_id table.
      */
    override def snapshot(request: io.deephaven.proto.backplane.grpc.table.SnapshotTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SNAPSHOT, options, request)
    }
    
    /**
      * Snapshot base_id, triggered by trigger_id, and export the resulting new table.
      * The trigger_id table's change events cause a new snapshot to be taken. The result table includes a
      * "snapshot key" which is a subset (possibly all) of the base_id table's columns. The
      * remaining columns in the result table come from base_id table, the table being snapshotted.
      */
    override def snapshotWhen(request: io.deephaven.proto.backplane.grpc.table.SnapshotWhenTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SNAPSHOT_WHEN, options, request)
    }
    
    /**
      * Returns a new table with a flattened row set.
      */
    override def flatten(request: io.deephaven.proto.backplane.grpc.table.FlattenRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_FLATTEN, options, request)
    }
    
    /** *
      * Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
      * X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
      * column to support zooming in.
      */
    override def runChartDownsample(request: io.deephaven.proto.backplane.grpc.table.RunChartDownsampleRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_RUN_CHART_DOWNSAMPLE, options, request)
    }
    
    /** *
      * Creates a new Table based on the provided configuration. This can be used as a regular table from the other methods
      * in this interface, or can be interacted with via the InputTableService to modify its contents.
      */
    override def createInputTable(request: io.deephaven.proto.backplane.grpc.table.CreateInputTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_CREATE_INPUT_TABLE, options, request)
    }
    
    /** *
      * Filters the left table based on the set of values in the right table.
      *
      * Note that when the right table ticks, all of the rows in the left table are going to be re-evaluated,
      * thus the intention is that the right table is fairly slow moving compared with the left table.
      */
    override def whereIn(request: io.deephaven.proto.backplane.grpc.table.WhereInRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_WHERE_IN, options, request)
    }
    
    /**
      * Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
      * requiring them to be exported and managed by the client. The server will automatically release any tables when they
      * are no longer depended upon.
      */
    override def batch(request: io.deephaven.proto.backplane.grpc.table.BatchTableRequest, responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse]): _root_.scala.Unit = {
      _root_.scalapb.grpc.ClientCalls.asyncServerStreamingCall(channel, METHOD_BATCH, options, request, responseObserver)
    }
    
    /**
      * Establish a stream of table updates for cheap notifications of table size updates.
      *
      * New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
      * exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
      * initial update had been sent.
      */
    override def exportedTableUpdates(request: io.deephaven.proto.backplane.grpc.table.ExportedTableUpdatesRequest, responseObserver: _root_.io.grpc.stub.StreamObserver[io.deephaven.proto.backplane.grpc.table.ExportedTableUpdateMessage]): _root_.scala.Unit = {
      _root_.scalapb.grpc.ClientCalls.asyncServerStreamingCall(channel, METHOD_EXPORTED_TABLE_UPDATES, options, request, responseObserver)
    }
    
    /**
      * Seek a row number within a table.
      */
    override def seekRow(request: io.deephaven.proto.backplane.grpc.table.SeekRowRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.SeekRowResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SEEK_ROW, options, request)
    }
    
    /**
      * Returns the meta table of a table.
      */
    override def metaTable(request: io.deephaven.proto.backplane.grpc.table.MetaTableRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_META_TABLE, options, request)
    }
    
    /** *
      * Returns a new table representing statistics about a single column of the provided table. This
      * result table will be static - use Aggregation() instead for updating results. Presently, the
      * primary use case for this is the Deephaven Web UI.
      */
    override def computeColumnStatistics(request: io.deephaven.proto.backplane.grpc.table.ColumnStatisticsRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_COMPUTE_COLUMN_STATISTICS, options, request)
    }
    
    /** *
      * Returns a new table representing a sliced subset of the original table. The start position is inclusive
      * and the end position is exclusive. If a negative value is given, then the position is counted from the end of
      * the table.
      */
    override def slice(request: io.deephaven.proto.backplane.grpc.table.SliceRequest): scala.concurrent.Future[io.deephaven.proto.backplane.grpc.table.ExportedTableCreationResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_SLICE, options, request)
    }
    
    override def build(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): TableServiceStub = new TableServiceStub(channel, options)
  }
  
  object TableServiceStub extends _root_.io.grpc.stub.AbstractStub.StubFactory[TableServiceStub] {
    override def newStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): TableServiceStub = new TableServiceStub(channel, options)
    
    implicit val stubFactory: _root_.io.grpc.stub.AbstractStub.StubFactory[TableServiceStub] = this
  }
  
  def bindService(serviceImpl: TableService, executionContext: scala.concurrent.ExecutionContext): _root_.io.grpc.ServerServiceDefinition = TableService.bindService(serviceImpl, executionContext)
  
  def blockingStub(channel: _root_.io.grpc.Channel): TableServiceBlockingStub = new TableServiceBlockingStub(channel)
  
  def stub(channel: _root_.io.grpc.Channel): TableServiceStub = new TableServiceStub(channel)
  
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.ServiceDescriptor = io.deephaven.proto.backplane.grpc.table.TableProto.javaDescriptor.getServices().get(0)
  
}