// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package io.deephaven.proto.backplane.grpc.hierarchicaltable

/** @param snapshotSchema
  *   Schema to be used for snapshot or subscription requests as described in Arrow Message.fbs::Message.
  *   Field metadata is used to convey additional information about the structure of the HierarchicalTable, the
  *   special roles some columns play, and the relationships between columns.
  *  
  *   "hierarchicalTable.isStructuralColumn" is always "true" if set, and is set on columns that should be included on
  *   every snapshot or subscription request, but should not be directly user-visible.
  *  
  *   "hierarchicalTable.isExpandByColumn" is always "true" if set, and is set on all the columns that must be included
  *   in a HierarchicalTableViewRequest's key table, if a key table is specified. These columns are generally
  *   user-visible and displayed before other columns, unless they also have "hierarchicalTable.isStructuralColumn" set.
  *  
  *   "hierarchicalTable.isRowDepthColumn" is always "true" if set, and is set on a single column that specifies the
  *   depth of a row. That column will always have "hierarchicalTable.isExpandByColumn" set for RollupTables, but never
  *   for TreeTables.
  *  
  *   "hierarchicalTable.isRowExpandedColumn" is always "true" if set, and is set on a single nullable column of
  *   booleans that specifies whether a row is expandable or expanded. Values will be null for rows that are not
  *   expandable, true for expanded rows, false for rows that are not expanded (but expandable). Leaf rows have no
  *   children to expand, and hence will always have a null value for this column.
  *  
  *   "rollupTable.isAggregatedNodeColumn" is always "true" if set, and is set on all columns of a RollupTable that
  *   belong to the aggregated nodes.
  *  
  *   "rollupTable.isConstituentNodeColumn" is always "true" if set, and is set on all columns of a RollupTable that
  *   belong to the constituent nodes. No such columns will be present if constituents are not included in the
  *   RollupTable.
  *  
  *   "rollupTable.isGroupByColumn" is always "true" if set, and is set on all columns of a RollupTable that are
  *   "group-by columns", whether the node is aggregated or constituent. All nodes have the same names and types for
  *   columns labeled in this way. Such columns will always have "hierarchicalTable.isExpandByColumn" set if and only if
  *   they also have "rollupTable.isAggregatedNodeColumn" set.
  *  
  *   "rollupTable.aggregationInputColumnName" is set to the (string) name of the corresponding constituent column that
  *   was used as input to this aggregation node column. May have an empty value, because some aggregations take no
  *   input columns, for example "Count". This is only ever present on columns with "rollupTable.isAggregatedNodeColumn"
  *   set.
  *  
  *   "treeTable.isNodeColumn" is always "true" if set, and is set on all columns of a TreeTable that nodes inherit from
  *   the source Table.
  *  
  *   "treeTable.isIdentifierColumn" is always "true" if set, and is set on the single column that uniquely identifies a
  *   TreeTable row and links it to its children. Such columns will always have "hierarchicalTable.isExpandByColumn"
  *   set.
  *  
  *   "treeTable.isParentIdentifierColumn" is always "true" if set, and is set on the single column that links a
  *   TreeTable row to its parent row.
  * @param isStatic
  *   Whether or not this table might change.
  */
@SerialVersionUID(0L)
final case class HierarchicalTableDescriptor(
    snapshotSchema: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY,
    isStatic: _root_.scala.Boolean = false,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[HierarchicalTableDescriptor] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = snapshotSchema
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(1, __value)
        }
      };
      
      {
        val __value = isStatic
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = snapshotSchema
        if (!__v.isEmpty) {
          _output__.writeBytes(1, __v)
        }
      };
      {
        val __v = isStatic
        if (__v != false) {
          _output__.writeBool(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withSnapshotSchema(__v: _root_.com.google.protobuf.ByteString): HierarchicalTableDescriptor = copy(snapshotSchema = __v)
    def withIsStatic(__v: _root_.scala.Boolean): HierarchicalTableDescriptor = copy(isStatic = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = snapshotSchema
          if (__t != _root_.com.google.protobuf.ByteString.EMPTY) __t else null
        }
        case 2 => {
          val __t = isStatic
          if (__t != false) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PByteString(snapshotSchema)
        case 2 => _root_.scalapb.descriptors.PBoolean(isStatic)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor.type = io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor
    // @@protoc_insertion_point(GeneratedMessage[io.deephaven.proto.backplane.grpc.HierarchicalTableDescriptor])
}

object HierarchicalTableDescriptor extends scalapb.GeneratedMessageCompanion[io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor = {
    var __snapshotSchema: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY
    var __isStatic: _root_.scala.Boolean = false
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __snapshotSchema = _input__.readBytes()
        case 16 =>
          __isStatic = _input__.readBool()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor(
        snapshotSchema = __snapshotSchema,
        isStatic = __isStatic,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor(
        snapshotSchema = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.com.google.protobuf.ByteString]).getOrElse(_root_.com.google.protobuf.ByteString.EMPTY),
        isStatic = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Boolean]).getOrElse(false)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = HierarchicaltableProto.javaDescriptor.getMessageTypes().get(7)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = HierarchicaltableProto.scalaDescriptor.messages(7)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor(
    snapshotSchema = _root_.com.google.protobuf.ByteString.EMPTY,
    isStatic = false
  )
  implicit class HierarchicalTableDescriptorLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor](_l) {
    def snapshotSchema: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.snapshotSchema)((c_, f_) => c_.copy(snapshotSchema = f_))
    def isStatic: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.isStatic)((c_, f_) => c_.copy(isStatic = f_))
  }
  final val SNAPSHOT_SCHEMA_FIELD_NUMBER = 1
  final val IS_STATIC_FIELD_NUMBER = 2
  def of(
    snapshotSchema: _root_.com.google.protobuf.ByteString,
    isStatic: _root_.scala.Boolean
  ): _root_.io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor = _root_.io.deephaven.proto.backplane.grpc.hierarchicaltable.HierarchicalTableDescriptor(
    snapshotSchema,
    isStatic
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[io.deephaven.proto.backplane.grpc.HierarchicalTableDescriptor])
}
